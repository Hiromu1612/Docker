・Docker：「データやプログラムをコンテナで独立した環境に隔離できる」仕組みで
            主にサーバで使う
            パソコン → Word, Excel, Outlook等を同時に立ち上げる
            サーバ → Apache, MySQL等複数のプログラム(ソフトウェア)を同時に動かす
            Dockerを使うには、Dockerのソフトウェア(Docker Engine)をインストールするとコンテナを作成したり、動かせる

・コンテナ：イメージ(image)と呼ばれるコンテナの素になるものからDocker Engineで作成する
            コンテナはDocker Engineの上にいくつも載せることができる
            中に入れるソフトウェアによって、用意されたイメージを使う
            例：ApacheのコンテナならApacheのイメージ
                MySQLのコンテナならMySQLのイメージ

            DockerはWindowsやMacでも動かせるが、必ずLinux(サーバでよく使われるOS)が必要
            コンテナに入れるプログラムもLinux用のプログラム、これはDockerがLinux OSで使うことを前提としているため

・なぜDockerで隔離させるのか：多くのプログラムは、何らかの実行環境やライブラリ等を利用しており、1つのプログラムを変更すると他のプログラムに不具合が出ることがある
                            通常、1台のサーバやパソコンには、1つしか入れられないソフトウェアが多い(Word, Excelは複数存在しない)
                            Dockerなら、複数のコンテナに異なるバージョンを入れることができる

・サーバとは：「何かのサービス(Service)を提供(Serve)するもの」
            パソコンは個人が使うのに対し、サーバは複数の人がアクセスして使うだけの違い(サーバ用のOSの上にソフトウェアが動いているのは同じ)
            
            開発現場で使う「サーバ」は２通りの意味がある
            1.「機能としてのサーバ」
                Webサーバ、メールサーバ(Web機能・メール機能を提供するサーバ)
            2.「物理的なマシンとしてのサーバ」
                デスクトップパソコンのような現物
            
            2に複数の「機能としてのサーバ」を同居させることができる

            ソフトウェアをインストールすれば、サーバの機能を持つ
            例：Webサーバ用のソフトウェア(Apache)を入れる → Webサーバになる
                メールサーバ用のソフトウェアを入れる → メールサーバになる
            つまり、機能としてのサーバは同居できる

・代表的なサーバ
    ・Webサーバ：Webサイトの機能を提供するサーバ。HTMLファイルや画像ファイル、プログラムなどを置いておく。
                クライアントのブラウザがアクセスしてくると、それらのファイルを提供する
                    例：Apache, Nginx, IIS
    
    ・メールサーバ：SMTPサーバ(メールの送受信)とPOPサーバ(クライアントにメールを受信させる)がある
                    これら2つを合わせてメールサーバと呼ぶことが多い
                        例：Sendmail, Postfix, Dovecot
    
    ・データベースサーバ：データを保存したり、検索したりするためのデータベースを置くサーバ。
                            例：MySQL, PostgreSQL, MariaDB, SQLserver, Oracle Database
    
    ・ファイルサーバ：ファイルを保存して共有するためのサーバ。
                        例：Samba
    
    ・DNSサーバ：IPアドレスとドメインを結び付けるDNS機能を持つサーバ。

    ・DHCPサーバ：IPアドレスを自動的に振る機能を持つサーバ。

    ・FTPサーバ, プロキシサーバ, 認証サーバなど


・サーバ用のOS：Windows系 - Windows
               UNIX系    - Linux系(Red Hat, CentOS, Debian, Ubuntu, SUSE, openSUSE)
                           BSD系(macOS, FreeBSD, NetBSD)
                           Solaris系(Solaris, OpenSolaris)


・コンテナは持ち運べる：実際は一度書き出して、別のDocker上に再構築するが、Dockerから別のマシンのDockerにコンテナを移せると考えてよい
                        そのため、コンテナを全員に配布し、開発環境を一気に整えたり、開発サーバで作ったものをそのまま本番サーバへ持っていける
                        Dockerさえ入っていれば良いので、OSの違いやサーバ構成の違いを無視できて楽


・Dockerの仕組み：      コンテナ(プログラム・データ＋Linux OSっぽいもの)
                        Docker Engine(Dockerのソフトウェア)
                            Linux OS(サーバ用OS)
                    Server Machine(物理的なマシンとしてのサーバ)


・コンテナの中身：コンテナの中身は空ではなく、必ず「Linux OSっぽいもの」が入っている。完全なOSではない。

・そもそもOSとは：ソフトウェアやプログラムの命令をハードウェア(機械)に伝える
                例：ソフトウェア「みかんを食べて」
                            ↓
                    OS「テーブルの上に置いてあるみかんを手に取って皮をむいて食べて」
                            ↓
                    ハードウェア「OK」
                
・OSの構造：「カーネル」と呼ばれる核になる部分＋その周辺部分
                周辺部分 → プログラムから命令を受け取り、カーネルに伝える
                カーネル → ハードウェアを操作する
            
            コンテナ(Linux OSの周辺部分)
                        ↓
                Docker Engine
                        ↓
                    カーネル
                        ↓
                    ハードウェア

            Dockerの場合、コンテナは完全に分離されており、Linux OSの周辺部分がコンテナの中にあるプログラムを受け取れない。そのため、コンテナ内にOSの周辺部分を入れて
            プログラムの命令を受け取り、土台のカーネルに伝える
            コンテナの中にはLinux OSの周辺部分しか入ってないため、ぽいものという言い回し。
            Linux OSを丸ごとではなく、カーネルは土台に任せることで、Dockerの特徴の「軽い」になる


・Windows・MacでDockerを動かす：
    1. VirtualBox・VMwareのような仮想環境の上に、Linux OSをインストールして、その上でDockerを動かす
    2. Docker Desktop for Windows/Mac のようなDockerの実行に必要なLinuxを含むパッケージをインストールする


・イメージとコンテナ：イメージ(設計図)→コンテナ(製造物)：同じコンテナを複数作りたいときに便利
                     コンテナ→イメージ                ：作成したコンテナを変えて、新たなイメージ(設計図)ができる

・DockerからDockerへ移動できる：コンテナはDocker Engineの上であれば動くため、移動先のサーバやパソコンにDocker Engineをインストールして
                                元のコンテナから書き出したイメージを使って、同じコンテナを再構築すればよい
                                ※実際にはコンテナ自体を持ち運ぶわけではないが、イメージに書き出すことで移動している


・Docker Hub：Docker Hubはイメージ(コンテナの素)がたくさん集まっている、インターネット上のイメージ配布場所
              「1コンテナ = 1アプリ」：1つのコンテナに、1つのアプリしか入れないという意味で、セキュリティ面やバージョン管理などのメンテナンスのしやすさがメリット
                例：WordPressを構築したいとき。
                    ・WordPress
                    ・Apache
                    ・MySQL     
                     Dockerにするか、3コンテナにするか


・コンテナのライフサイクル：コンテナを「作る」→「起動する」→「停止する」→「破棄する」→「作る」という一連の流れのこと
                            ソフトウェア入りのコンテナは簡単に作れるため、1つのコンテナをアップデートして大事に使うのではなく、作り直して新しいバージョンに乗り換える

・データの保存：コンテナを破棄した場合、そのコンテナ内のファイルも破棄される
                そのため、Dockerをインストールした物理的なマシンのディスク(HDD/SDD)にマウントし、そこに保存する


・Dockerの使い道
    ・開発現場で全員に同じ開発環境を提供する
        プロジェクトごとにコンテナを使用したり、開発環境から本番環境に移行する際のずれがない
    
    ・新バージョンの実験に使う
        新しいOSやバージョンが出てきたときに、物理的なマシンとの相性を考えずにテストできる
    
    ・1つの物理的なマシンに同じサーバをいくつも立てられる
        コマンド1つで必要なサーバを立ち上げられるため、OSを入れてログインしてソフトを入れて・・・と繰り返す手間が省ける


・Dockerの操作
    docker  container    run       -d      test --mode=1
          上位コマンド 副コマンド オプション 対象 引数

<<<<<<< HEAD
docker run = docker pull, create, start : イメージのダウンロード・コンテナの作成・起動

docker stop → docker rm : 停止していないコンテナの場合、エラーが出て削除できない

・オプション
    -d     : バックグラウンドで実行する(detach)                   これがないと、起動したコンテナがプログラムの実行を終えるまで制御を握って次のコマンドが打てない ※1度限り実行するコンテナの場合は、実行後すぐに終了するため問題ない
    -i     : コンテナに操作端末(キーボード)をつなぐ(interactive) 
    -t     : 特殊キーを使用可能にする(tty)                        これらがないと、コンテナの中身を操作できない
    --name : コンテナ名
    -help  : 使い方を表示する
    -net = ネットワーク名 : コンテナをネットワークに接続する
    -p ホストのポート番号：コンテナのポート番号(publish)
    -v ホストのディスク：コンテナのディレクトリ  ボリュームをマウントする(volume)
    -e 環境変数名 = 値 (env)


docker ps (docker container ls) -a：停止しているものも含めた全てのコンテナの一覧を表示する


Apache：Webサーバ機能を提供するソフトウェア
        Apacheが動いているサーバにHTML・画像ファイルを置けば、Webサイトとして見られる
        ブラウザでアクセスできるようにするには、Apacheの入ったコンテナを外部と接続する = ポート(port)、通信の出入り口。 Webは80,メールは25
                                                                                      コンテナ中のApacheは待機しているだけなので、母体となる物理的なマシンがコンテナに伝える
-p 8080(ホスト)：80(コンテナ)
    母体のポート番号は他のソフトが使用しているポート番号と被らなければ、任意の数字でよい
    なお、複数のWebサーバを並列する場合、母体のポート番号をずらして設定する コンテナ側のポート番号は80で重複してもよい(この番号はイメージの作者が決めるので変更できない)




・イメージの削除：コンテナは削除しても、イメージはたまり続けてストレージを圧迫する
                 コンテナが存在していると消せないので、コンテナを停止・削除する

docker image ls : イメージ一覧を表示。-aは不要。コンテナと違って動いている・止まっている状態がないから。 docker ps = docker container lsと同じ感じ 
                  REPOSITORY(イメージ名)・TAG(バージョン情報)
                
docker image rm イメージ名 イメージ名 イメージ名  スペースで複数のイメージを削除できる




・WordPressの構築：WordPressコンテナ(WordPress, Apache, PHPの実行環境) + MySQLコンテナ(MySQL)
                   LAMP環境：Linux + Apache, MySQL, PHP のような
                   「Linux + Webサーバ + データベース + プログラミング言語の実行環境」の組み合わせが基本
                  仮想的なネットワークを作り、コンテナ同士をつなげる
・副コマンド
    connect     : コンテナをネットワークに接続する
    disconnect  : コンテナをネットワークから切断する
    create      : ネットワークを作る
    inspect     : ネットワークの詳細情報を表示する
    ls          : ネットワークの一覧を表示する
    rm          : 指定したネットワークを削除する
    prune       : 現在コンテナが繋がっていないネットワーク全てを削除する


よく使う記述例
 docker run --name コンテナ名
            -dit
            --net = ネットワーク名
            -e MYSQL_ROOT_PASSWORD = ルートのパスワード
            -e MYSQL_DATABASE = データベース名
            -e MYSQL_USER = ユーザー名
            -e MYSQL_PASSWORD = ユーザーのパスワード
            mysql(対象)
            --character-set-server = 文字コード(utf8mb4)
            --collation-server = 照合順序(utf8mb4_unicode_ci)
            --default-authentication-plugin = 認証方式(mysql_native_password) ※MySQL5からMySQL8へと変わる際に外部ソフトウェアから接続する認証方式が変更され、
                                                                               まだ対応していないソフトウェアがあるので旧式のMySQLに接続
                                                                            



・コンテナとホスト(PC)間でファイルをコピーする
    HTML/CSSファイルをWordPress上の操作でサーバに保存されているが、時にはソフトウェアを介さずにサーバと自分のPCでファイルのやり取りをしたい → コピー

docker cp ホスト側のパス コンテナ名：コンテナ側のパス (PC→コンテナ)  apa000ex1:/usr/local/apache2/htdocs/   mysql000ex1:/var/lib/mysql などデータの保存場所はDockerイメージのドキュメン参照
docker cp コンテナ名：コンテナ側のパス ホスト側のパス (コンテナ→PC)
つまり、コピー元 → コピー先 の順で記述する





・ボリュームとマウント
    ボリューム：ストレージ(ハードディスクやSSD)の一部分を区切ったもの
    マウント  ：取り付ける。対象とOS・ソフトウェアを接続する。データを外部ストレージに保存して移し替えるイメージ

    コンテナは「作っては壊す」ので、コンテナ内にデータが残っていると一緒に消えてしまう。そのため、一般的にはいちいち移し替えずに最初から外に保存してアクセスする(=データの永続化)

    Dockerに記憶領域(ボリューム)をマウントするには、2種類の方法がある
        1. ボリュームマウント
            Docker Engineが管理している領域内にボリュームを作成し、ディスクとしてコンテナにマウントする
            名前だけで管理できるので、手軽に扱えるが、ボリュームに対して直接操作しづらい → 「滅多に触らないが、消してはいけないファイル」を置く
                Windows, Mac, Linuxでディレクトリのパスが違うので書き換える必要があるが、Docker Engine上にあるため、配布が楽でDocker社はこちらを推奨
                ただ、Dockerコンテナを経由せずに直接ボリュームにアクセスできない。無理に変更を加えるとボリュームが壊れる恐れがある。
                バックアップも単純なコピーではなく、LinuxOSのみ入った別のコンテナに該当のボリュームをマウントし、そこでバックアップ操作をする必要があり、面倒。
            

        2. バインドマウント
            DockerをインストールしたPCにマウントする。
            普通のファイルのようにフォルダに対して直接ファイルを置いたり、開いたりできる → 「頻繁に触りたいファイル」を置く
        
        記憶領域のマウントは「run」コマンドのオプションとして指定 → マウントしたい記憶領域のパスを、コンテナの特定の場所であるように設定することでマウントする
                                                                  =マウントしたい記憶領域は別の場所(Docker Engineの上か、OSの上)だが、コンテナ内に記憶領域のショートカットを作るイメージ
・記憶領域をマウントする手順
    1. 記憶領域を作る
    2. コンテナを作る(マウントする)

・副コマンド
    create  : ボリュームを作る
    inspect : ボリュームの詳細情報を表示する
    ls      : ボリュームの一覧を表示する
    rm      : 指定したボリュームを削除する
    prune   : 現在マウントされていないボリュームをすべて削除する

・よく使う記述例
    ボリュームマウント：docker run -v ボリューム名：コンテナの記憶領域パス
    バインドマウント  ：docker run -v 実際の記憶領域パス：コンテナの記憶領域パス




・コンテナのイメージ化
    イメージの作成方法は2つある
        1. 既にあるコンテナを「commit」してイメージの書き出しをする方法
            コンテナがあれば、コマンド一つで作成でき手軽
            既にあるコンテナを複製したり、移動したいときに使う
            docker commit コンテナ名 作成するイメージ名

        2. 「Dockerfile」を「build」してイメージにする方法
            Dockerfileには元となるイメージ、実行したいコマンドなどを記載する
            同じフォルダ内にコンテナ内部に入れたいファイルを置いておく。実際のコンテナを作る必要はない。
            docker build -t 作成するイメージ名 フォルダのパス
                Dockerfileの記述例
                    FROM イメージ名
                    COPY コピー元パス(相対パス) コピー先パス
                    RUN Linuxのコマンド

・Dockerfileのコマンド
    FROM       : 元にするイメージを指定する
    ADD        : イメージにファイルやフォルダを追加する
    RUN        : イメージをビルドするときにコマンドを実行する
    CMD        : コンテナを起動するときに実行する既定のコマンドを指定する
    ENTRYPOINT : イメージを実行するときのコマンドを強要する
    ONBUILD    : ビルドが完了したときに任意の命令を実行する
    EXPOSE     : 通信を想定するポートをイメージの利用者に伝える
    VOLUME     : 永続データが保存される場所をイメージの利用者に伝える
    ENV        : 環境変数を定義する
    WORKDIR    : RUN,CMD,ENTRYPOINT,ADD,COPYの際の作業ディレクトリを指定する
    SHELL      : ビルド時のシェルを指定する
    LABEL      : 名前やバージョン番号、制作者情報などを設定する
    USER       : RUN,CMD,ENTRYPOINTで指定するコマンドを実行するユーザー、グループを設定する
    ARG        : docker buildする際に指定できる引数を宣言する
    STOPSIGNAL : docker stop する際にコンテナで実行しているプログラムに対して送信するシグナルを変更する
    HEALTHCHECK: コンテナの死活確認をするヘルスチェックの方法をカスタマイズする


・イメージを持ち運ぶには「save」でtarファイルにする
    コンテナはそのままでは移動・コピーできない。「save」コマンドで「tar」ファイルにしてDocker支配下からホスト側に移動する
    ファイルからイメージとして取り込みたいときは「load」コマンドを使う
        tarファイル：.tar形式のアーカイブファイル
                     .tarとは。圧縮・解凍ソフトやUNIX系OSでよく使われる「tar」コマンドで解凍できる
                     アーカイブファイルとは、「複数のファイルやフォルダを1つにまとめたファイル」

     docker save -o ファイル名.tar 作るイメージ名


・コンテナの改造
    2つの方法があり、両方を併用することがほとんど

    1. ファイルのコピー・記憶領域のマウント
    2. Linuxのコマンドでソフトウェアのインストールや設定の書き換えを行う

    コンテナに対してLinuxのコマンドで命令するには「shell」と呼ばれる命令を伝えるプログラムが必要で、
    sh・csh・tcsh等があるが、最も一般的でコンテナ内に入っている「bash」を介して命令する

    コンテナは何も指定せずに起動すると、bashが動いていない状態なので、
    「docker exec(コンテナ内でコマンドを実行)」「docker run」の引数に 
     /bin/bash  をつける
        docker exec
            起動中のコンテナにrunするわけにはいかないので、bashを使わずに直接命令を送ることができるが、
            初期設定されていないために動かない場合がある。よって、基本的にはshellを通して実行する
        docker run 
            コンテナに入っているソフトウェア(Apache・MySQLなど)を動かす代わりに、bash(新しいソフトウェア)を動かすので、コンテナは作られているものの、ソフトウェアがスタートしていない状態
            →bashでの操作が終わった後、改めて「docker start」でスタートする必要がある ※このような場合、docker execを使うことが多い
    
    bashが起動すると、操作対象はDocker Engine(Dockerコマンドでコンテナの作成削除などを命令)ではなく、該当のコンテナ(bashコマンドで命令)になる
    bashを使ってコンテナ内部に命令するときは、Dockerコマンドが効かない

    つまり、コンテナ内部をbashで命令し終えたら、コンテナから抜けてDocker Engineへの命令に切り替える
    exit : コンテナ内の操作から出る

    ・Dockerで行う操作       : コンテナ全体の管理に関わる操作(Docker Engine自身の開始・終了, 実行中のコンテナ一覧, コンテナの作成・起動・停止, イメージのダウンロード)
    ・コンテナ内部で行う操作  : ソフトウェアの追加・実行・停止, 設定変更, コンテナ間のファイルコピー・移動

    なお、Dockerへの命令はOSに関係なく同じだったが、コンテナ内部への命令のコマンドはOSっぽいもののLinuxの系によって、流儀が異なりコマンドも異なる
     → Docker公式が「特に理由がなければ、Debian系をベースにすると良い」と言っているため、多くのコンテナがDebian系

    ・Linuxのディストリビューション
        Windows
        Mac
        Linux -- RedHat系(RedHat, CentOS)           yum install httpd
              -- Debian系(Debian, Ubuntu, Fedora)   apt install apache2
              -- Alpine