・Docker：「データやプログラムをコンテナで独立した環境に隔離できる」仕組みで
            主にサーバで使う
            パソコン → Word, Excel, Outlook等を同時に立ち上げる
            サーバ → Apache, MySQL等複数のプログラム(ソフトウェア)を同時に動かす
            Dockerを使うには、Dockerのソフトウェア(Docker Engine)をインストールするとコンテナを作成したり、動かせる

・コンテナ：イメージ(image)と呼ばれるコンテナの素になるものからDocker Engineで作成する
            コンテナはDocker Engineの上にいくつも載せることができる
            中に入れるソフトウェアによって、用意されたイメージを使う
            例：ApacheのコンテナならApacheのイメージ
                MySQLのコンテナならMySQLのイメージ

            DockerはWindowsやMacでも動かせるが、必ずLinux(サーバでよく使われるOS)が必要
            コンテナに入れるプログラムもLinux用のプログラム、これはDockerがLinux OSで使うことを前提としているため

・なぜDockerで隔離させるのか：多くのプログラムは、何らかの実行環境やライブラリ等を利用しており、1つのプログラムを変更すると他のプログラムに不具合が出ることがある
                            通常、1台のサーバやパソコンには、1つしか入れられないソフトウェアが多い(Word, Excelは複数存在しない)
                            Dockerなら、複数のコンテナに異なるバージョンを入れることができる

・サーバとは：「何かのサービス(Service)を提供(Serve)するもの」
            パソコンは個人が使うのに対し、サーバは複数の人がアクセスして使うだけの違い(サーバ用のOSの上にソフトウェアが動いているのは同じ)
            
            開発現場で使う「サーバ」は２通りの意味がある
            1.「機能としてのサーバ」
                Webサーバ、メールサーバ(Web機能・メール機能を提供するサーバ)
            2.「物理的なマシンとしてのサーバ」
                デスクトップパソコンのような現物
            
            2に複数の「機能としてのサーバ」を同居させることができる

            ソフトウェアをインストールすれば、サーバの機能を持つ
            例：Webサーバ用のソフトウェア(Apache)を入れる → Webサーバになる
                メールサーバ用のソフトウェアを入れる → メールサーバになる
            つまり、機能としてのサーバは同居できる

・代表的なサーバ
    ・Webサーバ：Webサイトの機能を提供するサーバ。HTMLファイルや画像ファイル、プログラムなどを置いておく。
                クライアントのブラウザがアクセスしてくると、それらのファイルを提供する
                    例：Apache, Nginx, IIS
    
    ・メールサーバ：SMTPサーバ(メールの送受信)とPOPサーバ(クライアントにメールを受信させる)がある
                    これら2つを合わせてメールサーバと呼ぶことが多い
                        例：Sendmail, Postfix, Dovecot
    
    ・データベースサーバ：データを保存したり、検索したりするためのデータベースを置くサーバ。
                            例：MySQL, PostgreSQL, MariaDB, SQLserver, Oracle Database
    
    ・ファイルサーバ：ファイルを保存して共有するためのサーバ。
                        例：Samba
    
    ・DNSサーバ：IPアドレスとドメインを結び付けるDNS機能を持つサーバ。

    ・DHCPサーバ：IPアドレスを自動的に振る機能を持つサーバ。

    ・FTPサーバ, プロキシサーバ, 認証サーバなど


・サーバ用のOS：Windows系 - Windows
               UNIX系    - Linux系(Red Hat, CentOS, Debian, Ubuntu, SUSE, openSUSE)
                           BSD系(macOS, FreeBSD, NetBSD)
                           Solaris系(Solaris, OpenSolaris)


・コンテナは持ち運べる：実際は一度書き出して、別のDocker上に再構築するが、Dockerから別のマシンのDockerにコンテナを移せると考えてよい
                        そのため、コンテナを全員に配布し、開発環境を一気に整えたり、開発サーバで作ったものをそのまま本番サーバへ持っていける
                        Dockerさえ入っていれば良いので、OSの違いやサーバ構成の違いを無視できて楽


・Dockerの仕組み：      コンテナ(プログラム・データ＋Linux OSっぽいもの)
                        Docker Engine(Dockerのソフトウェア)
                            Linux OS(サーバ用OS)
                    Server Machine(物理的なマシンとしてのサーバ)


・コンテナの中身：コンテナの中身は空ではなく、必ず「Linux OSっぽいもの」が入っている。完全なOSではない。

・そもそもOSとは：ソフトウェアやプログラムの命令をハードウェア(機械)に伝える
                例：ソフトウェア「みかんを食べて」
                            ↓
                    OS「テーブルの上に置いてあるみかんを手に取って皮をむいて食べて」
                            ↓
                    ハードウェア「OK」
                
・OSの構造：「カーネル」と呼ばれる核になる部分＋その周辺部分
                周辺部分 → プログラムから命令を受け取り、カーネルに伝える
                カーネル → ハードウェアを操作する
            
            コンテナ(Linux OSの周辺部分)
                        ↓
                Docker Engine
                        ↓
                    カーネル
                        ↓
                    ハードウェア

            Dockerの場合、コンテナは完全に分離されており、Linux OSの周辺部分がコンテナの中にあるプログラムを受け取れない。そのため、コンテナ内にOSの周辺部分を入れて
            プログラムの命令を受け取り、土台のカーネルに伝える
            コンテナの中にはLinux OSの周辺部分しか入ってないため、ぽいものという言い回し。
            Linux OSを丸ごとではなく、カーネルは土台に任せることで、Dockerの特徴の「軽い」になる


・Windows・MacでDockerを動かす：
    1. VirtualBox・VMwareのような仮想環境の上に、Linux OSをインストールして、その上でDockerを動かす
    2. Docker Desktop for Windows/Mac のようなDockerの実行に必要なLinuxを含むパッケージをインストールする


・イメージとコンテナ：イメージ(設計図)→コンテナ(製造物)：同じコンテナを複数作りたいときに便利
                     コンテナ→イメージ                ：作成したコンテナを変えて、新たなイメージ(設計図)ができる

・DockerからDockerへ移動できる：コンテナはDocker Engineの上であれば動くため、移動先のサーバやパソコンにDocker Engineをインストールして
                                元のコンテナから書き出したイメージを使って、同じコンテナを再構築すればよい
                                ※実際にはコンテナ自体を持ち運ぶわけではないが、イメージに書き出すことで移動している


・Docker Hub：Docker Hubはイメージ(コンテナの素)がたくさん集まっている、インターネット上のイメージ配布場所
              「1コンテナ = 1アプリ」：1つのコンテナに、1つのアプリしか入れないという意味で、セキュリティ面やバージョン管理などのメンテナンスのしやすさがメリット
                例：WordPressを構築したいとき。
                    ・WordPress
                    ・Apache
                    ・MySQL     
                     Dockerにするか、3コンテナにするか


・コンテナのライフサイクル：コンテナを「作る」→「起動する」→「停止する」→「破棄する」→「作る」という一連の流れのこと
                            ソフトウェア入りのコンテナは簡単に作れるため、1つのコンテナをアップデートして大事に使うのではなく、作り直して新しいバージョンに乗り換える

・データの保存：コンテナを破棄した場合、そのコンテナ内のファイルも破棄される
                そのため、Dockerをインストールした物理的なマシンのディスク(HDD/SDD)にマウントし、そこに保存する


・Dockerの使い道
    ・開発現場で全員に同じ開発環境を提供する
        プロジェクトごとにコンテナを使用したり、開発環境から本番環境に移行する際のずれがない
    
    ・新バージョンの実験に使う
        新しいOSやバージョンが出てきたときに、物理的なマシンとの相性を考えずにテストできる
    
    ・1つの物理的なマシンに同じサーバをいくつも立てられる
        コマンド1つで必要なサーバを立ち上げられるため、OSを入れてログインしてソフトを入れて・・・と繰り返す手間が省ける


・Dockerの操作
    docker  container    run       -d      test --mode=1
          上位コマンド 副コマンド オプション 対象 引数

<<<<<<< HEAD
docker run = docker pull, create, start : イメージのダウンロード・コンテナの作成・起動

docker stop → docker rm : 停止していないコンテナの場合、エラーが出て削除できない

・オプション
    -d     : バックグラウンドで実行する(detach)                   これがないと、起動したコンテナがプログラムの実行を終えるまで制御を握って次のコマンドが打てない ※1度限り実行するコンテナの場合は、実行後すぐに終了するため問題ない
    -i     : コンテナに操作端末(キーボード)をつなぐ(interactive) 
    -t     : 特殊キーを使用可能にする(tty)                        これらがないと、コンテナの中身を操作できない
    --name : コンテナ名
    -help  : 使い方を表示する
    -net = ネットワーク名 : コンテナをネットワークに接続する
    -p ホストのポート番号：コンテナのポート番号(publish)
    -v ホストのディスク：コンテナのディレクトリ  ボリュームをマウントする(volume)
    -e 環境変数名 = 値 (env)


docker ps (docker container ls) -a：停止しているものも含めた全てのコンテナの一覧を表示する


Apache：Webサーバ機能を提供するソフトウェア
        Apacheが動いているサーバにHTML・画像ファイルを置けば、Webサイトとして見られる
        ブラウザでアクセスできるようにするには、Apacheの入ったコンテナを外部と接続する = ポート(port)、通信の出入り口。 Webは80,メールは25
                                                                                      コンテナ中のApacheは待機しているだけなので、母体となる物理的なマシンがコンテナに伝える
-p 8080(ホスト)：80(コンテナ)
    母体のポート番号は他のソフトが使用しているポート番号と被らなければ、任意の数字でよい
    なお、複数のWebサーバを並列する場合、母体のポート番号をずらして設定する コンテナ側のポート番号は80で重複してもよい(この番号はイメージの作者が決めるので変更できない)




・イメージの削除：コンテナは削除しても、イメージはたまり続けてストレージを圧迫する
                 コンテナが存在していると消せないので、コンテナを停止・削除する

docker image ls : イメージ一覧を表示。-aは不要。コンテナと違って動いている・止まっている状態がないから。 docker ps = docker container lsと同じ感じ 
                  REPOSITORY(イメージ名)・TAG(バージョン情報)
                
docker image rm イメージ名 イメージ名 イメージ名  スペースで複数のイメージを削除できる




・WordPressの構築：WordPressコンテナ(WordPress, Apache, PHPの実行環境) + MySQLコンテナ(MySQL)
                   LAMP環境：Linux + Apache, MySQL, PHP のような
                   「Linux + Webサーバ + データベース + プログラミング言語の実行環境」の組み合わせが基本
                  仮想的なネットワークを作り、コンテナ同士をつなげる
・副コマンド
    connect     : コンテナをネットワークに接続する
    disconnect  : コンテナをネットワークから切断する
    create      : ネットワークを作る
    inspect     : ネットワークの詳細情報を表示する
    ls          : ネットワークの一覧を表示する
    rm          : 指定したネットワークを削除する
    prune       : 現在コンテナが繋がっていないネットワーク全てを削除する


よく使う記述例
 docker run --name コンテナ名
            -dit
            --net = ネットワーク名
            -e MYSQL_ROOT_PASSWORD = ルートのパスワード
            -e MYSQL_DATABASE = データベース名
            -e MYSQL_USER = ユーザー名
            -e MYSQL_PASSWORD = ユーザーのパスワード
            mysql(対象)
            --character-set-server = 文字コード(utf8mb4)
            --collation-server = 照合順序(utf8mb4_unicode_ci)
            --default-authentication-plugin = 認証方式(mysql_native_password) ※MySQL5からMySQL8へと変わる際に外部ソフトウェアから接続する認証方式が変更され、
                                                                               まだ対応していないソフトウェアがあるので旧式のMySQLに接続
                                                                            



・コンテナとホスト(PC)間でファイルをコピーする
    HTML/CSSファイルをWordPress上の操作でサーバに保存されているが、時にはソフトウェアを介さずにサーバと自分のPCでファイルのやり取りをしたい → コピー

docker cp ホスト側のパス コンテナ名：コンテナ側のパス (PC→コンテナ)  apa000ex1:/usr/local/apache2/htdocs/   mysql000ex1:/var/lib/mysql などデータの保存場所はDockerイメージのドキュメン参照
docker cp コンテナ名：コンテナ側のパス ホスト側のパス (コンテナ→PC)
つまり、コピー元 → コピー先 の順で記述する





・ボリュームとマウント
    ボリューム：ストレージ(ハードディスクやSSD)の一部分を区切ったもの
    マウント  ：取り付ける。対象とOS・ソフトウェアを接続する。データを外部ストレージに保存して移し替えるイメージ

    コンテナは「作っては壊す」ので、コンテナ内にデータが残っていると一緒に消えてしまう。そのため、一般的にはいちいち移し替えずに最初から外に保存してアクセスする(=データの永続化)

    Dockerに記憶領域(ボリューム)をマウントするには、2種類の方法がある
        1. ボリュームマウント
            Docker Engineが管理している領域内にボリュームを作成し、ディスクとしてコンテナにマウントする
            名前だけで管理できるので、手軽に扱えるが、ボリュームに対して直接操作しづらい → 「滅多に触らないが、消してはいけないファイル」を置く
                Windows, Mac, Linuxでディレクトリのパスが違うので書き換える必要があるが、Docker Engine上にあるため、配布が楽でDocker社はこちらを推奨
                ただ、Dockerコンテナを経由せずに直接ボリュームにアクセスできない。無理に変更を加えるとボリュームが壊れる恐れがある。
                バックアップも単純なコピーではなく、LinuxOSのみ入った別のコンテナに該当のボリュームをマウントし、そこでバックアップ操作をする必要があり、面倒。
            

        2. バインドマウント
            DockerをインストールしたPCにマウントする。
            普通のファイルのようにフォルダに対して直接ファイルを置いたり、開いたりできる → 「頻繁に触りたいファイル」を置く
        
        記憶領域のマウントは「run」コマンドのオプションとして指定 → マウントしたい記憶領域のパスを、コンテナの特定の場所であるように設定することでマウントする
                                                                  =マウントしたい記憶領域は別の場所(Docker Engineの上か、OSの上)だが、コンテナ内に記憶領域のショートカットを作るイメージ
・記憶領域をマウントする手順
    1. 記憶領域を作る
    2. コンテナを作る(マウントする)

・副コマンド
    create  : ボリュームを作る
    inspect : ボリュームの詳細情報を表示する
    ls      : ボリュームの一覧を表示する
    rm      : 指定したボリュームを削除する
    prune   : 現在マウントされていないボリュームをすべて削除する

・よく使う記述例
    ボリュームマウント：docker run -v ボリューム名：コンテナの記憶領域パス
    バインドマウント  ：docker run -v 実際の記憶領域パス：コンテナの記憶領域パス




・コンテナのイメージ化
    イメージの作成方法は2つある
        1. 既にあるコンテナを「commit」してイメージの書き出しをする方法
            コンテナがあれば、コマンド一つで作成でき手軽
            既にあるコンテナを複製したり、移動したいときに使う
            docker commit コンテナ名 作成するイメージ名

        2. 「Dockerfile」を「build」してイメージにする方法
            Dockerfileには元となるイメージ、実行したいコマンドなどを記載する
            同じフォルダ内にコンテナ内部に入れたいファイルを置いておく。実際のコンテナを作る必要はない。
            docker build -t 作成するイメージ名 フォルダのパス
                Dockerfileの記述例
                    FROM イメージ名
                    COPY コピー元パス(相対パス) コピー先パス
                    RUN Linuxのコマンド

・Dockerfileのコマンド
    FROM       : 元にするイメージを指定する
    ADD        : イメージにファイルやフォルダを追加する
    RUN        : イメージをビルドするときにコマンドを実行する
    CMD        : コンテナを起動するときに実行する既定のコマンドを指定する
    ENTRYPOINT : イメージを実行するときのコマンドを強要する
    ONBUILD    : ビルドが完了したときに任意の命令を実行する
    EXPOSE     : 通信を想定するポートをイメージの利用者に伝える
    VOLUME     : 永続データが保存される場所をイメージの利用者に伝える
    ENV        : 環境変数を定義する
    WORKDIR    : RUN,CMD,ENTRYPOINT,ADD,COPYの際の作業ディレクトリを指定する
    SHELL      : ビルド時のシェルを指定する
    LABEL      : 名前やバージョン番号、制作者情報などを設定する
    USER       : RUN,CMD,ENTRYPOINTで指定するコマンドを実行するユーザー、グループを設定する
    ARG        : docker buildする際に指定できる引数を宣言する
    STOPSIGNAL : docker stop する際にコンテナで実行しているプログラムに対して送信するシグナルを変更する
    HEALTHCHECK: コンテナの死活確認をするヘルスチェックの方法をカスタマイズする


・イメージを持ち運ぶには「save」でtarファイルにする
    コンテナはそのままでは移動・コピーできない。「save」コマンドで「tar」ファイルにしてDocker支配下からホスト側に移動する
    ファイルからイメージとして取り込みたいときは「load」コマンドを使う
        tarファイル：.tar形式のアーカイブファイル
                     .tarとは。圧縮・解凍ソフトやUNIX系OSでよく使われる「tar」コマンドで解凍できる
                     アーカイブファイルとは、「複数のファイルやフォルダを1つにまとめたファイル」

     docker save -o ファイル名.tar 作るイメージ名


・コンテナの改造
    2つの方法があり、両方を併用することがほとんど

    1. ファイルのコピー・記憶領域のマウント
    2. Linuxのコマンドでソフトウェアのインストールや設定の書き換えを行う

    コンテナに対してLinuxのコマンドで命令するには「shell」と呼ばれる命令を伝えるプログラムが必要で、
    sh・csh・tcsh等があるが、最も一般的でコンテナ内に入っている「bash」を介して命令する

    コンテナは何も指定せずに起動すると、bashが動いていない状態なので、
    「docker exec(コンテナ内でコマンドを実行)」「docker run」の引数に 
     /bin/bash  をつける
        docker exec
            起動中のコンテナにrunするわけにはいかないので、bashを使わずに直接命令を送ることができるが、
            初期設定されていないために動かない場合がある。よって、基本的にはshellを通して実行する
        docker run 
            コンテナに入っているソフトウェア(Apache・MySQLなど)を動かす代わりに、bash(新しいソフトウェア)を動かすので、コンテナは作られているものの、ソフトウェアがスタートしていない状態
            →bashでの操作が終わった後、改めて「docker start」でスタートする必要がある ※このような場合、docker execを使うことが多い
    
    bashが起動すると、操作対象はDocker Engine(Dockerコマンドでコンテナの作成削除などを命令)ではなく、該当のコンテナ(bashコマンドで命令)になる
    bashを使ってコンテナ内部に命令するときは、Dockerコマンドが効かない

    つまり、コンテナ内部をbashで命令し終えたら、コンテナから抜けてDocker Engineへの命令に切り替える
    exit : コンテナ内の操作から出る

    ・Dockerで行う操作       : コンテナ全体の管理に関わる操作(Docker Engine自身の開始・終了, 実行中のコンテナ一覧, コンテナの作成・起動・停止, イメージのダウンロード)
    ・コンテナ内部で行う操作  : ソフトウェアの追加・実行・停止, 設定変更, コンテナ間のファイルコピー・移動

    なお、Dockerへの命令はOSに関係なく同じだったが、コンテナ内部への命令のコマンドはOSっぽいもののLinuxの系によって、流儀が異なりコマンドも異なる
     → Docker公式が「特に理由がなければ、Debian系をベースにすると良い」と言っているため、多くのコンテナがDebian系

    ・Linuxのディストリビューション
        Windows
        Mac
        Linux -- RedHat系(RedHat, CentOS)           yum install httpd
              -- Debian系(Debian, Ubuntu, Fedora)   apt install apache2
              -- Alpine



・Docker Hubへの登録
    ・イメージをどこに置くのか
        「docker run」は自動的にDocker Hubからイメージをダウンロードしている
        自作のイメージも、Docker Hunに置ける
    
    ・Dockerレジストリ：イメージの配布場所(レジストリの集まり)
                       この中に、Docker Hub(Docker社の公式レジストリで、Apache・MySQL・Ubuntu等の公式イメージがある)やほかの企業・個人が作ったレジストリがある
        
        レジストリ(登記場所)：イメージの配布場所
        リポジトリ(倉庫)    : レジストリの中をさらに区切った単位で、ソフトウェア単位で作る

        Docker HubではリポジトリがそれぞれIDを持つ
        イメージのアップロードにはタグをつける必要がある

      タグ名
        レジストリの場所(Docker Hubの場合はID) / リポジトリ名：バージョン
        例：localhost:5000/apache:12
            test.commm/apache:13

    ・イメージにタグ名をつけて複製するdocker tag(docker image tag)
        docker tag 元のイメージ名 レジストリの場所/新しいリポジトリ名：バージョン
    
    ・イメージをアップロードするdocker push(docker image push)
        docker push レジストリの場所/新しいリポジトリ名：バージョン
    

    開発会社なら、プライベートなDockerレジストリを作り、Docker Hubで公開し、開発環境を配布するとよい
    ・プライベートレジストリを作る方法
        レジストリ用コンテナ(registry)を使う。ポート番号は5000
        docker run -d -p 5000:5000 registry


・Docker Compose：構築に関わるコマンド文の内容を１つのテキストファイル(定義ファイル)に書き込んで、一気に実行(up)・停止・削除(down)できるもの
                  YML形式(YAML Ain't a Markup Language):プログラムやソフトのデータを箇条書きで書くtxtファイル jsonファイルの上位互換
                  Docker Compose, Kubernetesでは、コンテナの集合体を「Service」と呼ぶ
                  同じ構成のコンテナを複数作るには、upコマンドに--scaleオプションをつける。Kubernetesの方が便利なのでscaleはあまり使わない
                    docker compose -f フォルダパス up --scale penguin=3
                    で、「フォルダ名_penguin_1,2,3」と3つのコンテナが起動する
                  定義ファイルは、コンテナ・ネットワーク・ボリュームなどの設定項目をコマンド文のように記述する。似てはいるがコマンド文ではない。

                  「up」コマンドはdocker runに似ていて定義ファイルの内容に従って、イメージのダウンロード・コンテナの作成起動などを行う
                  「down」コマンドはコンテナ・ネットワークを停止・削除する  
                                    ボリューム・イメージはそのまま
                   「stop」コマンドはコンテナ・ネットワークを停止する
                                    ボリューム・イメージはそのまま

                docker compose -f 定義ファイルのパス up オプション(-dなど)
                                                    down
                                                    stop
                詳しいオプション項目はP.222参照
                    
    ・Dockerfileとの違い：テキストファイルに定義を書いて実行する点は同じだが、実行内容が違う
        Dockerfile    ：イメージを作る
        Docker Compose：コンテナ・ネットワーク・ボリュームを作る
    
    ・Docker Composeを使うには：以前はソフトウェアをインストールする必要があったが、Docker Compose V2が発表され、Dockerコマンドとして使えるようになった
                              土台となるPC上にフォルダを作りそこに定義ファイル(YML形式)を置く
                              複数の定義ファイルを使いたいときは、その分だけDocker Compose用のフォルダも必要
                              定義ファイルの名前は必ず「docker-compose.yml」。引数(-f)を指定すると変更可能
                              定義ファイル・Docker ComposeはOS上だが、Docker Engine(Dockerコマンド)でコンテナに命令する = 人が手打ちでDocker Engineに命令していたのを、Docker Composeが代理で打ち込んでいるイメージ
    
    ・定義ファイル(Composeファイル)の書き方
        大項目 → 名前 → 設定 の順で書く
          例：Services → コンテナ名・ネットワーク名・ボリューム名 → 設定変更
        半角スペース1,2,3個でもよいが、タブは禁止。YML形式はスペースに意味がある言語。
        1度「半角スペース1個」で下げたら、それ以降の行はそれが基準になる
        名前の後ろの：(コロン)の後は半角スペースが1個必要
        #     :コメントアウト
        "",'' :文字列

        version: "3"
        services:
          コンテナ名1:
            image: イメージ名
            networks: 
              - ネットワーク名
            volumes:
              ボリューム名1:
              ボリューム名2:

・よく使う大項目
    services : コンテナに関する定義をする
    networks : ネットワークに関する定義をする
    volumes  : ボリュームに関する定義をする

・よく使う設定  docker runとの対応
    image    :なし
    networks : --netと同じ
    volumes  : -v, --mount
    ports    : -p
    environment: -e
    depends_on : なし。別のサービスに依存することを示す。 wordpressコンテナ内でdepends_on : -mysqlと書かれていれば、mysqlコンテナ作成後にwordpressコンテナが作られる
    restart    : なし。コンテナが停止したときの再試行ポリシーを設定する
                 no            : 何もしない
                 always        : 必ず再起動する
                 on-failure    : プロセスが0以外のステータスで終了したときは再起動する
                 unless-stopped: 停止していた時は再起動しない。それ以外は再起動する



・MySQLコンテナとWordPressコンテナを定義ファイル(docker-compose.yml)で作る
    まず、大項目と名前を書く
    version: "3"
    services:
      mysql000ex11:
      wordpress000ex12:
    networks:
      wordpress000net1:
    volumes:
      mysql000vol11:
      wordpress000vol12:

    その後、設定を書く
    services:
      mysql000ex11:
        image: mysql:5.7
      networks:
        - mysql000net1
      volumes:
        - mysql000vol11:/var/lib/mysql
      restart: always
      environment:
        MYSQL_ROOT_PASSWORD: myrootpass
        MYSQL_DATABASE: wordpress000db
        MYSQL_USER: wordpress000kun
        MYSQL_PASSWORD: wordpresspass

      wordpress000ex12:
        同様に書く






・Kubernetes：コンテナのオーケストレーションツールであり、Dockerとは別のソフトウェア
              オーケストレーションツールとは、システム全体の統括をし、複数のコンテナを管理できるもの(オーケストラの指揮者)
              ここでいう「複数」とは、全く同じ構成のコンテナ(＝サーバー)が複数ということで、大規模なシステムを管理する機会は少ない
              k8sというスラングもある。k,sの間に8文字ある

・Kubernetesは複数の物理マシン(仮想マシンでも可)に、複数のコンテナがあることが前提
    例えば、20個のコンテナを20回dockerコマンドする 
    → Docker Composeを使うにしても、物理マシンが多いと順番に接続して面倒 
    → マニフェストファイル(定義ファイル)を作れば管理が楽

・Kubernetesは「マスタ―ノード」というコントロールをするノードと、「ワーカーノード」という実際に動かすノードで構成される
  ノードは物理的なマシンと同じものと考えてよい
  パソコンから操作するのは、マスタ―ノードの初期設定・調整だけで、ワーカーノードを直接管理することはない(マスターが定義ファイルに基づきワーカーに命令)

  クラスター：マスタ―ノード＋ワーカーノードで構成されたKubernetesシステムの一群のこと
      マスタ―ノード：コンテナは動かさず、ワーカーノード上のコンテナを管理するだけ
      ワーカーノード：コンテナを動かす実際のサーバー部分。Docker Engineなどのコンテナエンジンをインストールしておく必要がある。

・Kubernetesを使うには
    ・Kubernetesのソフトウェア
    ・CNI(仮想ネットワークのドライバ, Container Networking Interface)のインストール
        CNIとして代表的なソフトウェア → flannel, Calico, AWS VPC CNO

    ・etcdというデータベース(マスタ―ノードでコンテナの状態管理に使う)
    ・kubectl(マスタ―ノードの初期設定・調整で使う、クーベコントロール)
    ・Docker Engine(ワーカーノードでコンテナを動かすのに使う)

・コントロールプレーン(制御盤)：マスタ―ノードはコントロールプレーンで、ワーカーノードを管理する
                               以下の5つのコンポーネント(部品)で構成される
                               etcd以外はKubernetesに入っているので、etcdとKubernetesをインストールすればよい
  マスタ―ノード側の構成
    kube-apiserver           : 外部とやり取りをするプロセス。kubectlからの命令を受け取って実行する
    kube-controller-manager  : コントローラーを統括管理・実行する
    kube-scheduler           : Podをワーカーノードへと割り当てる
    cloud-controller-manager : クラウドサービスと連携して、サービスを作る
    etcd                     : クラスター情報を全管理するデータベース

  ワーカーノード側の構成
    kube-proxy               : ネットワーク通信をルーティングする仕組み
    kube-let                 : マスタ―ノード側のkube-schedulerと連携して、ワーカーノード上にPodを配置し実行する。
                               また、実行中のPodの状態を定期的に監視し、kube-schedulerへ通知する

・KubernetesとDocker Composeの違い
    Kubernetes：複数台のサーバを使う大規模なサービス
                「コンテナを〇個、ボリュームを〇個で構成する」というように、あるべき姿をYAML形式のファイルで定義し、その通りに自動でコンテナを作ったり削除して「維持」
                定義ファイル(マニフェスト)がデータベース(etcd)として管理され、コマンドで書き換えれる
                一方で、コマンドで直接コンテナを調整すると、手元の定義ファイルとetcdで情報が異なる場合があるので注意

    Docker Compose：１台のサーバを使う小規模なサービス
                    オプションの指定でコンテナの数は変えられるが、作成時にしか関与せず、監視していないため「作って終わり」

    ・Kubernetesは1台でも使うのか：Podが障害などで無くなったときに自動で増やすなど、自動で管理してくれるので楽
                                  また、標準化されたコンテナの実行方法でシステムの納品に適している
                                  設定情報なども含めて配布できるため、インストール後の調整が簡単になる


・Kubernetesの構成：Podとサービス・デプロイメント・レプリカセット
        ロードバランサ―
           ｜
    ワーカーノード
        Cluster IP  デプロイメント
           ｜             ｜
        サービス    レプリカセット
           ｜           ｜
        レプリカ(同じ構成のPod)

    ・Pod：コンテナとボリュームがセットになったもの
           1Podに1コンテナ(複数コンテナも可)
           ボリュームはPodの中の複数のコンテナが情報共有するために使用するものなので、作らないことも多い

    ・サービス：同一の構成のPodをまとめて管理するもの
                ロードバランサ―(負荷分散装置)の役割。サービスごとに自動的に固定のIPアドレス(Cluster IP)が振られ、アクセスしてくる通信を分散させてサーバ1台への負荷を減らす
                サービスが振り分ける通信は、あくまでそのワーカーノード内のPodなので、ワーカーノード自体の振り分けは本物のロードバランサ―(負荷分散装置)が行う

    ・レプリカセット：Podの数を管理するもの
                     障害などでPodが停止したときに、足りないPodを増やしたり、定義ファイルでのPod数が減ったら、その分減らす

        ・レプリカ(複製品)：レプリカセットにより管理されている同一の構成のPodのこと

    ・デプロイメント(配置・展開)：Podの情報を持ち、デプロイを管理するもの


・定義ファイル(マニフェストファイル)の書き方
    YAML形式 or JSON形式で記述
    JSON形式はどちかというと機械的にやり取りするのが目的で、人間が読み書きする際はYAML形式が多い
    Docker Composeと異なり、ファイル名は何でもよい
    定義ファイルはリソース単位で記述する(サービス・デプロイメントなど)  リソースごとに分けても、「---」で区切って1つのファイルにまとめて書いてもよい
      例：ApacheのPodを作る
            「Apacheのサービス」と「Apacheのデプロイメント」のリソースを記述

・よく使う大項目  
    apiVersion : APIのグループとバージョン
    kind       : リソースの種類
    metadata   : メタデータ(リソースの名前・ラベルのこと) ラベルはキーと値のペアで特定のPodの設定ができる
    spec       : リソースの中身

    ・リソースのAPIグループ・バージョンと種類
        リソース        APIグループ・バージョン   種類(kind)
        Pod             core/v1 (v1と略せる)      Pod
        サービス        core/v1 (v1と略せる)      Service
        デプロイメント  apps/v1                   Deployment
        レプリカセット  apps/v1                   ReplicaSet

    ・メタデータ
        name              : リソースの名前(文字列)
        namespace         : リソースが細分化されるDNS互換のラベル
        uid               : 番号
        resourceVersion   : リソースバージョン
        generation        : 生成した順序の番号
        creationTimestamp : 作成日時
        deletionTimestamp : 削除日時
        labels            : ラベル
        anotation         : リソースに対して設定したい値。選択対象にならない

    例
        apiVersion:
        kind:
        metadata:
          name:     Podの名前
          labels:
        spec:
          container:
            - name: コンテナの名前
            image:
            ports: